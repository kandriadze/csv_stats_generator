-> Code State                0/20 (table.create_bq_table(config_file, schema_file) throws exception simultaneously, also  df.index.name = 'file'
        with open(output_file, 'r') as f: old_df = pd.read_json(f, orient='records', lines=True) in handler, its open mode is r (reader) when we want
        to create/write(it means it should be mode of w)
-> Clean code                7/15 No requirements.txt file
-> Structure                 10/15 No exception handling at all!
-> Approach                  4/10
-> Documentation             0/20 No documentation at all!
-> Version control State     2/20 No branching,no conventional commit messages

->->Grand Total:             23/100

მეორე თვის პროექტი: CSV ფაილების სტატ. მახასიათებლები და მათი შენახვა ქლაუდის ბაზებში

აღწერა: პროექტის მიზანია CSV ფაილების სტატისტიკური მახასიათებლების მიღება პითონის კოდით და
ამ ინფორმაციის ბაზაში განთავსება. რადგანაც ეს საქმე რუტინულია (ანუ ჩვენ ერთხელ არ გვინდა მხოლოდ ამ სტატისტიკის წარმოება,
არამედ უნდა ჰქონდეს სისტემატიური სახე), ესე იგი პროცესის ავტომატიზაციაა საჭირო.
ლინუქსის რომელიღაც კონკრეტულ დირექტორიაში ხდება CSV ფაილების თავმოყრა, ჩვენი მიზანი კი არის ამათ შესახებ ინფორმაცია აიტვირთოს
ბაზაში რეგულარულად. ეს პროცესი ხდება ყოველ საათში, შესაბამისად, თქვენი კოდი უნდა ეშვებოდეს ყოველ საათში ერთხელ და აკეთებდეს შემდეგ საქმეს:

მოთხოვნები:


1) კოდი უნდა იღებდეს ერთ კონფიგურაციის ფაილს, სადაც ყველა საჭირო ინფო იქნება (დასაწყისისთვის მინიმუმ ერთს მაინც -
იმ დირექტორიის path-ს, სადაც ეს CSV ფაილებია)

2) უნდა წაიკითხოთ ყველა csv ფაილი ამ დირექტორიაში და უნდა გვქონდეს შემდეგი მონაცემები მათზე:
       1 - ფაილის ზომა (ფიზიკური, მეგაბაიტებში, ანუ მყარ დისკზე რამდენსაც იკავებს)
       2 - Row-ების რაოდენობა (ჩანაწერების რაოდენობა) csv -ის წაკითხვის მერე, როგორც პანდასის DF
       3 - Column-ების რაოდენობა csv -ის წაკითხვის მერე, როგორც პანდასის DF
       4 - ერთი column-ის დაკავებული მეხსიერება (RAM-ში, ანუ ოპერატიურ მეხსიერებაში)
       5 - მთლიანად ამ DF-ის მიერ დაკავებული მეხსიერება (RAM-ში, აქაც)

3) ეს ცვლადები უნდა იყოს შენახული dict-ში, როგორც values და key უნდა იყოს csv ფაილის სახელი, საილუსტრაციოდ: 
[
   {
      "some.csv":{
         "csv_file_size_in_mb":20,
         "df_of_csv_rows_n":100,
         "df_of_csv_columns_n":3,
         "df_one_column_size_in_mb":0.9,
         "df_size_in_mb":4.5
      }
   },
   {
      "some1.csv":{
         "csv_file_size_in_mb":120,
         "df_of_csv_rows_n":10000,
         "df_of_csv_columns_n":13,
         "df_one_column_size_in_mb":1.1,
         "df_size_in_mb":7.5
      }
   }
]

4) ეს სია(list) dict-ების უნდა ჩაიწეროს json ფაილში, რომელსაც ერქმევა summary_{timestamp}.json და დაგენერირდება(შეიქმნება) იმავე დირექტორიაში,
სადაც csv-ებია (ანუ ყველა გაშვებაზე ერთი ახალი json უნდა გვქონდეს, შესაბამის დროითი ჭრილით - timestamp-ით)

5) ეს json-ები უნდა აიტანოთ ბაზაში, თუმცა წინა პუნქტისგან განსხვავებით, ბაზაში ერთ csv-ზე მხოლოდ ერთი ჩანაწერი უნდა არსებობდეს (შესაბამისად,
აქ უკვე მნიშვნელოვანია ვერსიების თემა, მეტადატა, created და modified ველების არსებობა ბაზაში და ა.შ)

6) ბაზაში არჩევანი თავისუფალია, თუმცა რადგანაც GCP უფასო ექაუნთით უნდა გააკეთოთ, ორი ძირითადი ვარიანტი გვაქვს: BigQuery და CloudSQL(engine-ის
არჩევაშიც თავისუფლებაა, MySQL, PostgreSQL ან SQL Server არის ხელმისაწვდომი)

7) კოდს უნდა გააჩნდეს version control-ი, ანუ სადმე git-ის კლიენტზე უნდა იყოს აწეული (GitHub, BitBucket, GitLab არჩ. თავისუფალია)

8) ბოლო და ბონუს პუნქტი: დაამატეთ რაიმე მინ. ერთი ახალი ფუნქციონალი რაც არაა მოთოხვნილი

დავალება შეფასდება თავიდან ბოლომდე ყველა პუნქტის გადაწყეტის შესაბამისად და დაიწერება ქულები შემდეგი პრიორიტეტებით:

-> Code State            - მუშაობს თუ არა კოდი გამართულად (ანუ ყველა ფუნქციონალი მუშა მდომარეობაშია, აკეთებს იმას, რასაც უნდა აკეთებდეს)
-> Clean code            - რამდენად მარტივია კოდის გაგება/წაკითხვადობა და ნათელია, რასაც ის ემსახურება
-> Structure             - კოდის სტრუქტურა(მოდულარულობა და ა.შ).
-> Approach              - რამდენად კარგად იქნება ეს ყველაფერი დალაგებული იდეურ დონეზე
-> Documentation         - არსებობს თუ არა ამ კოდის დოკუმენტაცია (readme.md ფაილი, შიდა დოკუმენტაცია ფუნქციონალში, კომენტარები)
-> Version control State - მისდევს თუ არა კოდი git-ის best practice-ებს

Total score: 100 ( 20, 15, 15, 10, 20, 20, შესაბამისად)